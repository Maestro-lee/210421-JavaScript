//38장 브라우저의 렌더링 과정
//토큰 - 문법적인 의미를 가지며, 문법적으로 더는 나눌 수 없는 코드의 기본 요소 의미
//렌더링 - HTML, CSS, 자바스크립트로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는것

//웹 애플리케이션의 클라이언트 사이드 자바스크립트는 브라우저에서 HTML, CSS와 함꼐 실행된다.
//브라우저가 HTML, CSS, 자바스크립트로 작성된 문서를 어떻게 파싱하여 브라우저에 렌더링 하는지.

//1. 요청과 응답
//필요한 리소스(HTML, CSS, JS, 이미지, 폰트 등의 정적 파일 또는 서버가 동적으로 생성한 데이터)를 서버에 요청, 서버로 부터 응답받아 브라우저에 렌더링
//요청-파싱-렌더링
//host 서버로 루트요청 전송. 
//서버는 루트 요청에 대해 서버의 루트 폴더에 존재하는 정적 파일 index.html을 클라이언트로 응답한다.

//2. HTTP1.1, HTTP2.0
//HTTP는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜(규약)이다.

//3. HTML 파싱과 DOM생성
    //HTML문서를 파싱하여 브라우저가 이해할 수 있는 자료구조인 DOM(Document Object Model)을 생성한다.
    //1. 서버에 존재하던 HTML파일이 브라우저의 요청에 이해 응답. 서버는 브라우저가 요청한 HTML파일을 읽어 들여 메모리에 저장한 다음 메모리에 저장된 바이트(2진수)를 인터넷을 경유하여 응답한다.
    //2. 브라우저는 서버가 응답한 HTML문서를 바이트 형태로 응답받는다. meta태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식을 기준으로 문자열로 변환한다. 
    //meta태그의 인코딩 방식은 응답헤더에 담겨 응답된다.
    //3.HTMLL문서를 읽어들여 문법적 의미를 갖는 코드의 최소단위인 토큰들로 분해한다.
    //4.토큰을 객체로 변환하여 노드를 생성한다. 내용에 따라 문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드가 생성된다. DOM을 구성하는 기본 요소가 된다.
    //5.HTML요소는 중첩 관게를 갖는다. HTML요소간에는 중첩 관계에 의해 부자 관계가 형성된다. 이러한 HTML요소 간의 부자관계를 반영하여 모든 노드들을 트리 자료구조로 구성한다.
    //DOM은 HTML문서를 파싱은 결과물이다.

    //1. 요청 2.바이트코드로 변환해 전달 3.브라우저 인코딩 방식에 따라 인코딩 4.토큰 생성 5. 토큰을 객체로 변환하여 노드 생성 DOM의 기본요소 6.HTML의 중첩관계, 부자관계를 통해 트리자료구조 생성

//4. CSS파싱과 CSSOM생성
    //DOM과 마찬가지로 1.바이트코드 2.문자 3.토큰 4.노드 5.CSSOM(CSS Object Model)생성. DOM생성중 CSS로드 태그 만날경우 멈추고 CSSOM생성
    //CSSOM은 CSS의 상속을 반영하여 생성된다.

//5. 렌더 트리 생성
    //DOM과 CSSOM은 렌더링을 위해 렌더 트리로 결합된다. 렌더 트리는 브라우저 화면에 렌더링되는 노드만으로 구성된다.
    //완성된 렌더트리는 각 HTML요소의 레이아웃을 계산하는데 사용되며, 브라우저 화면에 픽셀을 렌더링 하는 페인팅 처리에 입력된다.
    //반복해서 실행될 수 있다. 1. js에 의한 노드 추가 또는 삭제     2. 브라우저 창의 리사이징에 의한 뷰포트 크기 변경      3.HTML요소의 레이아웃에 변경을 발생시키는 스타일 변경
    //리렌더링은 성능에 악영향을 주는 작업이다. 가급적 빈번하게 발생하지 않도록 주의할 필요가 있다.

//6. 자바 스크립트 파싱과 실행
    //DOM은 DOM API를 제공한다. DOMAPI를 사용하면 이미 생성된 DOM을 동적으로 조작할 수 있다.
    //DOM생성>>js파일 로드태그 >>js엔진에 제어권 넘김>>파싱 종료 >> 렌더링 엔진으로 제어권 다시 넘김 js의 파싱과 실행은 js엔진이 처리한다.
    //JS를 해석하여 AST Abstract Syntax TREE추상적 구문 트리를 생성한다.
    // 토크나이징 tokenizing JS소스코드를 어휘분석lexical analysis하여 토큰으로 분해
    // 파싱 parsing 토큰 집합을 구문분석 하여 AST를 생성. 토큰에 문법적 의미와 구조를 반영한 트리 구조의 자료구조
    // 바이트코드 생성과 실행 AST는 바이트코드로 변환, 인터프리터에 의해 실행된다.

//7. 리플로우와 리페인트
    //DOM이나 CSSOM을 변경하는 DOM API 사용시 DOM 이나 CSSOM이 변경.
    //리플로우 - 레이아웃 계산을 다시 하는것. 노드 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이징 등 
    //리페인트 - 재결합된 렌더 트리를 기반으로 다시 페인트를 하는것.

//8. JS파싱에 의한 HTML파싱 중단
    //렌더링 엔진과 자바스크립트 엔진은 직렬적으로 파싱을 수행한다. 동기적synchronous이다.
    //script 태그 위치의 중요성 - HTML요소를 파싱하기 전에 script가 올 경우 id를 취득하지 못해 정상 동작하지 않는다. script태그의 위치에 의해 블로킹이 발생한다.
    
    //</body>태그 바로 위에 script태그를 위치시키는 것이 좋다 
    // - DOM이 완성되지 않은 상태에서 JS가 DOM을 조작하면 에러가 발생할 수 있다.
    // - js로딩/파싱/실행으로 인해 HTML 요소들의 렌더링에 지장받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다.
    //렌더링 엔진이 HTML요소를 모두 파싱하여 DOM생성을 완료한 이후이다. 블로킹 발생하지 않으며 DOM생성이 완료되어 렌더링 되므로 페이지 로딩 시간이 단축된다.

//9. script태그의 async/defer 어트리뷰트
    //js파싱에 의한 DOM생성중단 문제를 근본적으로 해결하기 위해 async, defer어트리뷰트 추가. src어트리뷰트를 통해 외부 js파일을 로드하는 경우에만 사용할 수 있다. 인라인 js에는 사용 불가.
    //async, defer 어트리뷰트 사용시 HTML 파싱과 외부 JS파일의 로드가 비동기장asynchronous으로 동시에 진행된다.

    //async 어트리뷰트 
    //- HTML파싱과 외부 js파일의 로드 비동기적 동시 진행. js파싱과 실행은 js파일 로드 완료 후 진행, 이 때 HTML파싱 중단.
    //- 여러개의 async어트리뷰트 지정시 순서 상관없이 로드 완료되는것부터 실행. 순서 보장이 필요한 script는 async지정 x

    //defer 어트리뷰트
    //- JS파싱과 실행은 html파싱이 완료된 직후, DOM생성이 완료된 직후(DOMContentLoaded이벤트가 발생한다.)진행된다.
    //- DOM생성이 완료된 이후 실행되어야 할 JS에 유용하다.